### TCP编程实验

| 班级       | 学号     | 姓名   |
| ---------- | -------- | ------ |
| 保密管理班 | 22336090 | 黄集瑞 |

---

##### 实验要求：

> 1. 使用TCP协议创建一个客户端-服务器聊天程序
> 2. 服务器能够接受多个客户端连接（不少于5个）
> 3. 当有一个新的客户与服务器建立连接时，服务器端显示该客户的地址和端口号
> 4. 当有一个客户与服务器断开连接时，服务器端显示该客户的地址和端口号
> 5. 当有一个客户向服务器发送消息，服务器显示来自该客户的信息

##### 实验原理：

> 为了实现基于TCP协议的客户端-服务器端聊天程序，我们需要先熟悉TCP协议建立的原理。TCP 协议是面向连接的协议，能够确保数据的可靠传输。它具有以下特点：
>
> * 可靠传输：通过确认应答机制，保证数据在传输过程中不会丢失或乱序。
> * 建立连接：通信双方必须先建立连接，然后才能传输数据。
> * 双向通信：数据能够同时在两个方向上传输。
>
> TCP具体的工作流程如下图所示：
>
> ![1729433988013](image/22336090_黄集瑞_TCP程序设计/1729433988013.png)

##### 实验过程

> * 服务器端的设计：
>   服务器端负责监听客户端的连接请求，并处理多个客户端的通信。设计该服务器有以下过程：**监听和接受客户端连接** ：服务器使用指定的 IP 地址和端口号监听来自客户端的连接请求。通过 `socket` 模块中的 `socket.bind()` 函数绑定到 IP 和端口号，然后通过 `socket.listen()` 函数等待客户端的连接（并且通过此设置最大的客户端连接数）；**多客户端处理** ：为了实现服务器同时处理多个客户端连接，服务器需要借助**多线程**来编写。在一开始时，本人使用过while循环来接受客户端的连接，但是却发现每次建立连接时，新建立的连接总是会覆盖掉原先的连接，所以本人后面便使用 `threading` 模块为每个客户端创建一个单独的线程，以便服务器能够同时与多个客户端通信：每当一个新客户端连接时，服务器会为该客户端启动一个新的线程来处理其消息；**消息处理** ：当一个客户端发送消息时，服务器需要能够正确接收并显示消息，同时也要做好客户端关闭时的异常处理。具体实现代码如下所示：
>
>   ```python
>   class TcpSever(object):
>       def __init__(self,ip,port):
>             self.code_mode = 'utf-8'
>             self.server_socket = socket(AF_INET, SOCK_STREAM) # 创建TCP socket并设置为TCP连接，并且是IPv4网络格式
>             self.server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 设置端口复用
>             self.server_socket.bind((ip, port)) # 绑定端口
>             self.server_socket.listen(10) # 设置最大的连接数
>             print("[服务器启动] 等待客户端连接……")  # 服务器启动后打印此消息
>   ```
>
>   这边我使用类来封装服务器的操作，能够使其更加利于管理，对应的操作后面也有注释详解，这里便不做过多赘述了。
>
>   ```python
>       def run(self):
>             while True:
>                 client_socket, client_address = self.server_socket.accept() # 等待客户端进行连接
>                 print("[连接建立] 客户端 ({},{}) 已连接".format(client_address[0], client_address[1])) # 连接建立后打印此消息
>                 client_thread = Thread(target=self.recv, args=(client_socket, client_address)) # 创建线程
>                 client_thread.start() # 启动线程
>             self.server_socket.close() # 关闭服务器(可写可不写，因为是不会执行的)
>
>   ```
>
>   在这段代码中，本人实现服务器端接受客户端连接并为每个连接创建一个独立线程的核心逻辑，使用了多线程来实现并发处理客户端的连接请求和消息传递。
>
>   ```python
>       def recv(self, client_socket, client_address):
>            while True:
>                 try:
>                       message = client_socket.recv(1024).decode(self.code_mode)
>                       if not message:
>                            break
>                       else:
>                            print("[来自({},{})的消息] {}".format(client_address[0], client_address[1], message))
>                            client_socket.send(message.encode(self.code_mode))
>                 except ConnectionResetError:
>                       break
>            print("[连接断开] 客户端 ({},{}) 已断开连接".format(client_address[0], client_address[1]))
>            client_socket.close()
>   ```
>
>   这段代码就是为了处理来自客户端的消息，在这里面我使用了try以及except来进行异常处理。因为在一开始时，我没有使用异常处理，但是仍然编写了客户端断开连接的代码，可是在客户端断开连接之后，并不会显示 ``print("[连接断开] 客户端 ({},{}) 已断开连接".format(client_address[0], client_address[1]))``这段话，而是显示如下图所示的报错：
>   ![1729435485510](image/22336090_黄集瑞_TCP程序设计/1729435485510.png)
>   所以，本人便加入了异常处理的代码，当客户端关闭了现有的连接时就检测 ``ConnectionResetError``，如果出现的话就代替成要求的关闭连接语句。
>
>   ```python
>   def main():
>        ip = '172.26.43.224'
>        port = 12000
>        my_server = TcpSever(ip,port)
>        my_server.run()
>
>   if __name__ == "__main__":
>       main()
>   ```
>
>   这里就是程序运行开始的地方，可以由使用者自行的去设定ip地址以及端口号。由于我是在同一台主机下进行实验，所以就填入当前我的主机所分配的ip地址。至此，服务器端的设计完成。
> * 客户端的设计：
>   客户端通过向服务器的 IP 地址和端口号发起连接请求，连接成功后，客户端可以向服务器发送消息。设计客户端程序有以下几点需要注意：**建立连接** ：客户端通过 `socket.connect()` 函数向服务器的 IP 地址和端口号发起连接请求，连接成功后，客户端可以开始发送和接收消息；**发送消息** ：客户端可以通过 `socket.send()` 函数向服务器发送消息，**接收服务器消息** ：客户端还可以接收来自服务器的消息，通常用于确认连接状态。但是由于客户端就是类似于用户本身，不需要进行什么线程管理，所以总体而言代码会相对简单较多。具体代码如下所示：
>
>   ```python
>   from socket import *
>   serverName = '172.26.43.224'
>   serverPort = 12000
>   clientSocket = socket(AF_INET, SOCK_STREAM)
>   clientSocket.connect((serverName,serverPort))
>   print("[连接到服务器] 你可以开始发送消息了(输入'exit' 退出)")
>   while True:
>       message = input()
>       if message.lower() == 'exit':
>           print("[连接断开] 客户端已断开连接")
>           clientSocket.close()
>           break
>       # 发送消息
>       clientSocket.send(message.encode('utf-8'))
>       print(f"你：{message}")
>       #modifiedSentence = clientSocket.recv(1024) 
>   ```
>
>   可以看出客户端的代码十分简洁，主体逻辑就是先与服务器进行连接 ``connect``操作，然后就可以一直向主机端发送消息 ``send``，直到客户端本身输入‘exit’。由于本实验不要求处理服务器对客户端的消息，所以相应的接受服务器消息这边就省略了。

##### 实验结果

> 1. 检测一个客户端连接情况：
>
>    ![1729436259203](image/22336090_黄集瑞_TCP程序设计/1729436259203.png)
>    可以看到由于先前的异常处理，服务器端这边也是正确显示了我们需要的，客户端的功能实现也十分正常。
> 2. 检测五个客户端连接情况：
>
>    ![1729436358075](image/22336090_黄集瑞_TCP程序设计/1729436358075.png)
>    从图中可以看出服务器端可以正常处理5个客户端连接情况，至此实验完成。
